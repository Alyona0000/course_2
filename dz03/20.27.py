#T20.27 Застосувати клас Decks для моделювання розкладів при грі у
#преферанс. У цю гру грають колодою з 32 карт, починаючи з 7, роздають 3
#гравцям по 10 карт, 2 карти залишаються у «прикупі». Старшинство карт – у
#порядку зростання гідності. На основі аналізу власних карт один з гравців
#може вибороти право визначати гру. Цей гравець бере прикуп, скидає 2
#«зайві» карти та оголошує козирну масть, яка «б’є» інші масті, а також
#кількість взяток, які він зобов’язується взяти. При кожному ході кожен з
#гравців кладе 1 карту та розігрується 1 взятка, яку забирає старша карта або
#козирна карта (старша з козирних карт, якщо їх декілька). Кожен з гравців
#зобов’язаний класти карту тієї масті, з якої зроблено хід. Якщо цієї масті
#немає, - то козирну карту. Якщо козирної карти немає, то будь-яку карту.
#Право наступного ходу отримує гравець, який взяв останню взятку.
#Для того, щоб при власному першому ході гарантовано взяти всі 10 взяток
#треба мати у масті, яка буде оголошена козирною, одну з таких комбінацій
#карт:

# туз, король, дама, валет;
# туз, король, дама та 2 будь-які менші карти;
# туз, король та 4 будь-які менші карти;
# туз та 6 будь-яких менших карт;
# всі вісім карт однієї масті.
#Треба також мати всі старші карти в усіх інших наявних мастях (або
#комбінацію у ще одній масті туза, короля, дами та 2 будь-яких менших карт
#за умови не більше 5 карт у козирній масті).
#Знайти ймовірність наявності на будь-якій руці розкладу, що дозволяє за
#умови власного першого ходу гарантовано взяти всі 10 взяток:
#а) без урахування прикупу;
#б) з урахуванням прикупу.
#Розв’язати задачу методом Монте-Карло з використанням масивів numpy.
#Векторизувати програмний код, наскільки можливо.

import numpy as np

class Decks:
    def __init__(self, num_decks=3, min_rank=2):
        # Формує вказану кількість колод карт.
        # Аргументи:
        #   num_decks – кількість колод
        #   min_rank – мінімальний ранг карти (2..14), де 11=J, 12=Q, 13=K, 14=A

        if not (2 <= min_rank <= 14):
            raise ValueError("Мінімальний ранг має бути від 2 до 14")
        # Перевірка правильності мінімального рангу

        suits = np.array([100, 200, 300, 400])
        # Кожній масті відповідає свій код:
        # 100 – піки ♠, 200 – черви ♥, 300 – бубни ♦, 400 – хрести ♣

        ranks = np.arange(min_rank, 15)
        # Формуємо ранги карт від min_rank до 14 (14 – це туз)

        one_deck = np.array([ranks + s for s in suits])
        # Створюємо одну колоду: до кожного коду масті додаємо ранг
        # Наприклад, 100+7=107 → сімка піка

        one_deck = one_deck.flatten()
        # Перетворюємо двовимірний масив у плоский (усі карти в один ряд)

        # Створюємо список незалежних колод (кожна перемішана)
        self.all_decks = [np.random.permutation(one_deck) for _ in range(num_decks)]
        # Кожна колода існує окремо й має свій порядок карт


        # старшенство карт ПИКИ ТРЕФИ БУБНА ЧЕРВА
        # (саме в такому порядку бо це старшенство карт тобто пики старша карта черви молодша, так само як туз старша карта а 7 моложша)
        # прикуп --- жто человек которий сидит и раздает карти (тобиш ми на рамдоме раздаем карти а потом чтоби в колоде (масиве осталось 2 карти))
        # після рздачі карт починається торговля (тобто гравці дивляться на свої 10 карт та оцінюють їх)
    def card_to_string(self, card: int) -> str:
        suit_names = {1: "♠️", 2: "♥️", 3: "♦️", 4: "♣️"}
        rank_names = {2: "2", 3: "3", 4: "4", 5: "5", 7: "7", 8: "8", 9: "9", 10: "10", 11: "J", 12: "Q", 13: "K", 14: "A"}
        return f"{suit_names[card // 100]}  {rank_names[card % 100]}"

    def set_to_string(self, set: np.ndarray) -> str:
        return "  ".join([self.card_to_string(card) for card in set])
    
    def deal(self, num_players, num_cards):
        # Роздає кожному гравцю по num_cards карт з КОЖНОЇ колоди
        num_decks = len(self.all_decks)
        # Знаходимо кількість колод

        dealt = [[] for _ in range(num_players)]
        # Створюємо список гравців; у кожного буде список карт із кожної колоди

        # Роздача з кожної колоди окремо
        for deck_index, deck in enumerate(self.all_decks):
           # print(f"\nРоздаємо карти з колоди №{deck_index + 1}")
            # Виводимо номер поточної колоди

            if num_players * num_cards > len(deck):
                raise ValueError(f"У колоді №{deck_index + 1} недостатньо карт!")

            for i in range(num_players):
                player_cards = deck[:num_cards]
                # Беремо перші num_cards карт із поточної колоди

                deck = deck[num_cards:]
                # Зменшуємо колоду після роздачі

                dealt[i].append(player_cards)
                # Додаємо карти з цієї колоди поточному гравцю

                #print(f"  Гравець {i + 1} отримав з колоди {deck_index + 1}: {player_cards}")

            # Оновлюємо стан колоди після роздачі
            self.all_decks[deck_index] = deck

       # print("\nПісля роздачі залишок карт у кожній колоді:")
        #for i, deck in enumerate(self.all_decks, start=1):
            #print(f"  Колода {i}: {len(deck)} карт залишилось")

        return dealt
        # Повертаємо список: у кожного гравця — масив карт із кожної колоди

# Метод Монте-Карло — это численный метод, использующий случайные числа для решения сложных задач в различных областях,
# таких как физика, экономика и управление проектами.








