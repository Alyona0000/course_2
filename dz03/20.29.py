#T20.29 В умовах задачі T20.28 визначити ймовірність розкладів при
#фіксованому роздаванні. Зафіксувати на першій руці карти так, щоб
#найкраща потенційно козирна масть складалась з 4 карт а також 2 карти,
#скинуті після взяття прикупу. Виконати фіксоване роздавання. Знайти
#ймовірності того, що на другій та третій руці інші 4 карти цієї масті роздано
#у співвідношенні 4:0, 1:3, 2:2, 3:1, 0:4.

#T20.28 В умовах попередньої задачі визначити ймовірність розкладів при грі
#у «мізер». Якщо один з гравців зобов’язується зіграти мізер, це означає
#зобов’язання за будь-яких умов не взяти жодної взятки. Для того, щоб
#гарантовано не взяти жодної взятки, за умови не власного першого ходу,
#треба у кожній наявній масті мати одну з таких комбінацій карт:
# комбінацію з однієї карти 7
# комбінацію з 2 карт 7, 8
# комбінацію з 2 карт 7, 9
# комбінацію з 3 карт: одну з комбінацій з 2 карт плюс 9 (для 7, 8) або 10
#або валет
# комбінацію з 4 карт: одну з комбінацій з 3 карт плюс 10 або валет
#(якщо 10 або валет немає у комбінації з 3 карт) або дама або король

# комбінацію з 5 або більше карт: одну з комбінацій з 4 карт плюс будь-
#які старші карти

#Знайти ймовірність наявності на будь-якій руці розкладу, що дозволяє за
#умови не власного першого ходу гарантовано не взяти жодної взятки:
#а) без урахування прикупу;
#б) з урахуванням прикупу.
#Розв’язати задачу методом Монте-Карло з використанням масивів numpy.
#Векторизувати програмний код, наскільки можливо.


#T20.27 Застосувати клас Decks для моделювання розкладів при грі у
#преферанс. У цю гру грають колодою з 32 карт, починаючи з 7, роздають 3
#гравцям по 10 карт, 2 карти залишаються у «прикупі». Старшинство карт – у
#порядку зростання гідності. На основі аналізу власних карт один з гравців
#може вибороти право визначати гру. Цей гравець бере прикуп, скидає 2
#«зайві» карти та оголошує козирну масть, яка «б’є» інші масті, а також
#кількість взяток, які він зобов’язується взяти. При кожному ході кожен з
#гравців кладе 1 карту та розігрується 1 взятка, яку забирає старша карта або
#козирна карта (старша з козирних карт, якщо їх декілька). Кожен з гравців
#зобов’язаний класти карту тієї масті, з якої зроблено хід. Якщо цієї масті
#немає, - то козирну карту. Якщо козирної карти немає, то будь-яку карту.
#Право наступного ходу отримує гравець, який взяв останню взятку.
#Для того, щоб при власному першому ході гарантовано взяти всі 10 взяток
#треба мати у масті, яка буде оголошена козирною, одну з таких комбінацій
#карт:

# туз, король, дама, валет;
# туз, король, дама та 2 будь-які менші карти;
# туз, король та 4 будь-які менші карти;
# туз та 6 будь-яких менших карт;
# всі вісім карт однієї масті.
#Треба також мати всі старші карти в усіх інших наявних мастях (або
#комбінацію у ще одній масті туза, короля, дами та 2 будь-яких менших карт
#за умови не більше 5 карт у козирній масті).
#Знайти ймовірність наявності на будь-якій руці розкладу, що дозволяє за
#умови власного першого ходу гарантовано взяти всі 10 взяток:
#а) без урахування прикупу;
#б) з урахуванням прикупу.
#Розв’язати задачу методом Монте-Карло з використанням масивів numpy.
#Векторизувати програмний код, наскільки можливо.


import numpy as np

# ==========================================================
# Клас Decks — не змінюю структуру, тільки логіку виправляю
# ==========================================================

class Decks:
    def __init__(self, num_decks=1):
        self.num_decks = num_decks
        self.one_deck = self.make_one_deck()
        self.deck_size = len(self.one_deck)

        # створюємо num_decks незалежних перетасованих колод
        self.all_decks = [np.random.permutation(self.one_deck) for _ in range(num_decks)]

    def make_one_deck(self):
        # масті 2, 3, 4, 5
        deck = np.concatenate([
            np.arange(200, 215),   # ♣
            np.arange(300, 315),   # ♦
            np.arange(400, 415),   # ♥
            np.arange(500, 515),   # ♠
        ])
        return deck

    # Функція роздачі — залишаю назву
    def deal(self, players=4, num_cards=5):
        # кожна колода = одна симуляція (Monte-Carlo)
        # у кожній симуляції ми роздаємо карти 4 гравцям і більше НЕ використовуємо цю колоду
        results = []

        for deck_index in range(self.num_decks):
            deck = self.all_decks[deck_index]

            # беремо 4 руки по 5 карт
            hands = [deck[i*num_cards:(i+1)*num_cards] for i in range(players)]
            results.append(hands)

        return results


# ==========================================================
# Визначення комбінацій у твоєму стилі
# ==========================================================

def case_1(hand_numbers):
    """
    4 карти однієї гідності (4 однакових ранги)
    """
    ranks = hand_numbers % 100
    uniq, counts = np.unique(ranks, return_counts=True)
    return np.any(counts == 4)


def case_2(hand_numbers):
    """
    Стріт-флаш: 5 карт однієї масті + ранги ідуть підряд
    """
    suits = hand_numbers // 100
    ranks = hand_numbers % 100

    # всі масті однакові
    cond_suits = np.unique(suits).size == 1

    # ранги йдуть як +1
    sorted_ranks = np.sort(ranks)
    cond_straight = np.all(np.diff(sorted_ranks) == 1)

    return cond_suits and cond_straight


# ==========================================================
# Приклад Monte-Carlo симуляції
# ==========================================================

def monte_carlo(num_sim=20000):
    decks = Decks(num_decks=num_sim)

    count_case_1 = 0
    count_case_2 = 0

    for sim in range(num_sim):
        hands = decks.deal(players=4, num_cards=5)[sim]

        for hand in hands:
            if case_1(hand):
                count_case_1 += 1
            if case_2(hand):
                count_case_2 += 1

    return count_case_1, count_case_2


# Запустити:
c1, c2 = monte_carlo(2000)
print("Випадки case_1:", c1)
print("Випадки case_2:", c2)
